# 一个优雅的动归

为了预防老年痴呆顺便维持手感，一个程序员应当时不时刷几道算法题挑战一下。记得之前上算法课的时候，我一直认为动归的题都是最简单的——套路嘛，遇事不决归一下（？）同时，动归的过程总会给人一种优雅的感觉：有的问题看上去那么复杂，仿佛一团乱麻，但抽丝剥茧，又总能找到最简单的那个S<sub>0</sub>。一生二，二生三，三生万物，大道归一，是哲学的优雅。感谢计算机，让我们不用自己从1数到万，只要敲下一个简单的for循环，嘬口咖啡的功夫不到，cpu就帮你把计算的脏活累活干完，正确的答案静静地显示在控制台等你审阅。

当然了，对于题目来说，自然不能都沿用同样的套路。一些带着稍许“变形”的题目，能让你在识破其中的马甲时被刺激出更多的多巴胺。这篇废话要记录的就是这样一个不那么标准的动归题：




```
LeetCode486. 预测玩家

给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。
```



简单来说，可以看做一个先手问题。两个人依次选数组头尾任意一个数，看谁最后拿的数字和最大，同时两个人都是拿数字高手，训练有素，一般不会输除非必须输。然后根据数组判断先手能不能赢。为了简便，在这道题中平局的情况视为先手玩家获胜。

不知道正常人类是否存在这样的拿数字高手，反正我不是。不过没关系，现代社会的人类都知道，一切繁琐的计算交给计算机嘛。对于我来说，我能一眼看穿的牌面是什么呢：


   1. **数组是空的——先手胜。**
   2. **数组只有一个数字——先手胜。**
   3. **数组只有两个数字——先手胜。**


那么，当数组的大小大于2，谁赢呢？

让我来假装自己是一个拿数字高手：**假设我可以算出来这个数组我先拿的情况下我最多可以拿到的和是多少，那么我也可以算出来我拿了头或者尾后，我的对手面对剩下的数组最多可以拿到多少。**

听起来很绕很晕对不对？我也觉得，所以我们成不了拿数字高手。不过没关系，很绕的逻辑写成代码却很简单：

`dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1])`

其中，`nums`为数组，`dp[i][j]`为数组从 `i` 到 `j` 的子数组中先手与后手得分的差值（即先手得分-后手得分）。这行代码妙在哪里呢？我们再看一眼题目：

```
给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。
```

题目中反复出现玩家1，玩家2的概念，很容易让读者陷入一种思维的禁锢：去思考玩家1和玩家2在拿数字的时候**各自的**路径选择问题。但实际上呢？这个游戏的本质是一个**交替先手**的问题，也就是说，不要再管玩家1还是玩家0还是玩家甲乙丙丁了！想象一个精分的拿数字高手自己和自己玩，他要做的就是让`dp[i][j]`尽可能的大，然后看看`dp[0][n-1]`（`n`为数组大小）最后是不是大于`0`就完事了！是不是很妙？表面上是两个玩家在玩拿数字，实际上你中有我我中有你，你的阴谋也是我的阳谋，谁也不比谁高明，谁也不比谁愚钝，就算你背了爱马仕，我只拎着小ck，在这场游戏中，我们的结局早已确定——猜到了这开头，也看穿了这结尾。

